// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package bizzomatetokenreplacer.actions;

import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.text.StringEscapeUtils;
import com.mendix.core.Core;
import com.mendix.core.CoreException;
import com.mendix.core.objectmanagement.member.MendixEnum;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixIdentifier;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.systemwideinterfaces.core.meta.IMetaEnumValue;
import com.mendix.systemwideinterfaces.core.meta.IMetaEnumeration;
import com.mendix.systemwideinterfaces.core.meta.IMetaObject;
import com.mendix.systemwideinterfaces.core.meta.IMetaPrimitive;
import com.mendix.webui.CustomJavaAction;
import bizzomatetokenreplacer.IMendixObjectBigDecimalComparator;
import bizzomatetokenreplacer.IMendixObjectComparable;
import bizzomatetokenreplacer.IMendixObjectDateComparator;
import bizzomatetokenreplacer.IMendixObjectIntComparator;
import bizzomatetokenreplacer.IMendixObjectStringComparator;
import bizzomatetokenreplacer.proxies.ContentParser;
import bizzomatetokenreplacer.proxies.DataType;
import bizzomatetokenreplacer.proxies.ParserMethod;
import bizzomatetokenreplacer.proxies.Sorting;
import bizzomatetokenreplacer.proxies.Token;
import bizzomatetokenreplacer.proxies.TokenObject;
import bizzomatetokenreplacer.proxies.TokenReplacer;
import bizzomatetokenreplacer.proxies.constants.Constants;

public class ReplaceTokens extends CustomJavaAction<java.lang.String>
{
	private IMendixObject __TokenReplacer;
	private bizzomatetokenreplacer.proxies.TokenReplacer TokenReplacer;
	private IMendixObject ValueObject;
	private java.lang.String Text;
	private java.lang.String LanguageCode;
	private java.lang.String TimeZoneID;

	public ReplaceTokens(IContext context, IMendixObject TokenReplacer, IMendixObject ValueObject, java.lang.String Text, java.lang.String LanguageCode, java.lang.String TimeZoneID)
	{
		super(context);
		this.__TokenReplacer = TokenReplacer;
		this.ValueObject = ValueObject;
		this.Text = Text;
		this.LanguageCode = LanguageCode;
		this.TimeZoneID = TimeZoneID;
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		this.TokenReplacer = __TokenReplacer == null ? null : bizzomatetokenreplacer.proxies.TokenReplacer.initialize(getContext(), __TokenReplacer);

		// BEGIN USER CODE

		// First check if the input is all correct.
		if (TokenReplacer == null) 
			throw new CoreException("Please provide a TokenReplacer object.");
		if (ValueObject == null)
			throw new CoreException("Please provide a value object.");
		if (Text.isEmpty())
			throw new CoreException("Please provide a text to parse.");
		if (LanguageCode.isEmpty())
			throw new CoreException("Please provide a language code.");

		lognode.debug(TokenReplacer.getTitle(context) + "; Language code " + LanguageCode + ". Replacing tokens in text (START)");
		lognode.trace(TokenReplacer.getTitle(context) + "; Language code " + LanguageCode + ". Text in: "
				+ Text);
		String parsedText = processTextWithTokenReplacer(TokenReplacer, ValueObject, Text, LanguageCode);
		lognode.trace(TokenReplacer.getTitle(context) + "; Language code " + LanguageCode + ". Parsed: "
				+ parsedText);
		lognode.info(TokenReplacer.getTitle(context) + "; Language code " + LanguageCode + ". Replaced tokens in text (END)");
		return parsedText;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ReplaceTokens";
	}

	// BEGIN EXTRA CODE
	
	private final static String TOKEN_LIST_START = "{%LIST_START%}";
	private final static String TOKEN_LIST_END = "{%LIST_END%}";
	
	private final IContext context = getContext();
	private final ILogNode lognode = Core.getLogger(Constants.getLogNode());
		
	private final Pattern tokenPattern = Pattern.compile(".*\\{\\%.+\\%\\}");
	private final Pattern tokenListPattern = Pattern.compile("\\{\\%LIST_START\\%\\}.*\\{\\%LIST_END\\%\\}", Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.MULTILINE);
		
	private Matcher tokenMatcher = null;
	
	private String processTextWithTokenReplacer(TokenReplacer tokenReplacer, IMendixObject valueObject, String text, String languageCode) throws CoreException
	{
		TokenObject mainTokenObject = tokenReplacer.getTokenObject_TokenReplacer_Main(context);
		List<IMendixObject> valueObjects = new ArrayList<>();
		valueObjects.add(valueObject);
		text = processTextForTokenObject(mainTokenObject, valueObjects, text, languageCode);
		text = text.replace(TOKEN_LIST_START, "").replace(TOKEN_LIST_END, ""); // For sure, although possible no list is processed.
		return text;
	}
	
	private String processTextForTokenObject(TokenObject tokenObject, List<IMendixObject> valueObjects, String text, String languageCode) throws CoreException
	{
		
		lognode.debug(TokenReplacer.getTitle(context) + "; Language code " + languageCode + "; Processing token object " + tokenObject.getMxObjectTypeCompleteName(context) + "; Sorting applied: " + tokenObject.getApplySorting(context) + ".");
		
		// If no tokens are to be parsed, return the current text
		if (!textContainsTokens(text))
			return text;
		
		IMendixObject valueObject = null;
		
		if (!valueObjects.isEmpty())
			valueObject = valueObjects.get(0);
		
		// Check first if multiple objects are possible
		// Removed || valueObjects.size() == 1 so processing lists keep correct.
		if (Boolean.TRUE.equals(tokenObject.getHasOneReferencedObjectOnly())) 
		{
			/*** SINGLE OBJECT ***/
			
			// Get all tokens of current tokenobject
			List<Token> tokenList = getTokenObjectTokens(tokenObject);
			
			// Iterate through tokens and parse them if necessary.
			for (Token token : tokenList) {
				text = processToken(context, valueObject, token, languageCode, text);
			}
			
			text = processSubTokenObjects(context, tokenObject, valueObject, languageCode, text);
			
		}
		else
		{
			/*** MULTIPLE OBJECTS ***/

			// Get all tokens of current tokenobject
			List<Token> tokenList = getTokenObjectTokens(tokenObject);

			// Iterate through tokens and parse them if necessary.
			for (Token token : tokenList) {

				if (tokenIsInsideListTokens(text, token.getCompleteToken(context)))
				{

					int listLevel = 1; // Contains level of depth of LISTS
					int indexOfToken = -1; // Contains index of current token
					int indexOfLastListStartBeforeToken = -1; // Contains index of LIST_START before token
					int indexOfMatchingListEndAfterToken = -1; // Contains index of matching LIST_END after token
					int indexOfListStartInBetween = -1;
					int indexOfLastListStartInBetween = -1;
					
					indexOfToken = text.indexOf(token.getCompleteToken(context));
					indexOfLastListStartBeforeToken = text.indexOf(TOKEN_LIST_START); 
					
					if (indexOfLastListStartBeforeToken >= 0) { // LIST_START token is found, otherwise it would be -1 which means processing the token as regular token.
						
						indexOfLastListStartInBetween = indexOfLastListStartBeforeToken;
						
						// Find last occurence of LIST_START before token.
						while (indexOfLastListStartInBetween >= 0) {
							indexOfLastListStartInBetween = text.indexOf(TOKEN_LIST_START, indexOfLastListStartInBetween + TOKEN_LIST_START.length());
							if (indexOfLastListStartInBetween >= 0 && indexOfLastListStartInBetween < indexOfToken) {
								indexOfLastListStartBeforeToken = indexOfLastListStartInBetween;
							} else {
								break;
							}
								
						}

						// Find the occurence of LIST_END + check if the next should be found, based on listLevel amount.
						indexOfListStartInBetween = text.indexOf(TOKEN_LIST_START, indexOfToken);
						indexOfMatchingListEndAfterToken = indexOfToken;
						
						while (listLevel > 0) {
							indexOfMatchingListEndAfterToken = text.indexOf(TOKEN_LIST_END, indexOfMatchingListEndAfterToken + TOKEN_LIST_END.length());
							if (indexOfListStartInBetween >= 0 && indexOfListStartInBetween < indexOfMatchingListEndAfterToken) {
								indexOfListStartInBetween = text.indexOf(TOKEN_LIST_START, indexOfListStartInBetween + TOKEN_LIST_START.length());
								listLevel += 1;
							}
							listLevel -= 1;
						}	
										
						String textOuter = text.substring(indexOfLastListStartBeforeToken, indexOfMatchingListEndAfterToken + TOKEN_LIST_END.length());
						int startInner = TOKEN_LIST_START.length();
						int endInner = textOuter.length() - TOKEN_LIST_END.length();
						
						StringBuilder textInnerBuilder = new StringBuilder();
						textInnerBuilder.append(textOuter.substring(startInner, endInner));
						String textInner = textInnerBuilder.toString();
						
						String newText = "";

						for (IMendixObject valueObjectMulti : valueObjects) {

							// Setup new line(s) of text for parsing for new value object.
							newText += textInner;

							for (Token tokenMulti : tokenList) {
								newText = processToken(context, valueObjectMulti, tokenMulti, languageCode, newText);
							}
							
							// Process further as single value object. Only provide the already extracted text here.							
							List<IMendixObject> valueObjectMultiSubs = new ArrayList<>();
							valueObjectMultiSubs.add(valueObjectMulti);
							
							newText = processSubTokenObjects(context, tokenObject, valueObjectMulti, languageCode, newText);
							
						}

						// Replace original part of text with new parsed text part.
						text = text.replace(textOuter, newText);
					}

				} 
				else
				{
					text = processToken(context, valueObject, token, languageCode, text);
				}

			}

			text = processSubTokenObjects(context, tokenObject, valueObject, languageCode, text);
			
		}
		
		return text;
	}
	
	
	private String processSubTokenObjects(IContext context, TokenObject tokenObject, IMendixObject valueObject, String languageCode, String text) throws CoreException {
		
		// Now process sub mapping objects if any.
		List<TokenObject> subTokenObjects = getTokenObjects(tokenObject, context);

		// Iterate through sub mapping objects and process them also. Also first get the valueObject.
		for (TokenObject subTokenObject : subTokenObjects) {
			
			List<IMendixObject> nextValueObjects = new ArrayList<>();

			if (Boolean.TRUE.equals(subTokenObject.getHasOneReferencedObjectOnly(context))) // IsParentAssociation
			{
				// Get associated value object via reference name. This solution works only with parent associations.
				IMendixIdentifier nextValueObjectIdentifier = null;
				
				if (valueObject != null) {
					nextValueObjectIdentifier = valueObject.getValue(context, subTokenObject.getMxObjectReferenceCompleteName(context));
				}
				
				// Check whether the associated object is filled. If not -> Skip.
				if ( nextValueObjectIdentifier != null ) {
					nextValueObjects.add(Core.retrieveId(context, nextValueObjectIdentifier));
				}		
			}
			else
			{
				// Retrieves first list and then gets the first one. Works however is probably slower.
				List<IMendixObject> subValueObjects = Core.retrieveByPath(context, valueObject, subTokenObject.getMxObjectReferenceCompleteName(context));
				
				// Build new list to add invalid objects to.
				List<IMendixObject> subValueObjectsToRemove = new ArrayList<>();
				
				// Check per retrieve value object if it is valid to use.
				for (IMendixObject subValueObject : subValueObjects) {
					lognode.debug("SubValueObject: " + subValueObject.getType() + " - " + subValueObject.getMetaObject().getName());
					if (!isValidType(subTokenObject.getMxObjectTypeCompleteName(context), subValueObject))
						subValueObjectsToRemove.add(subValueObject);
				}
				
				// Remove invalid value objects from list.
				for (IMendixObject subValueObjectToRemove : subValueObjectsToRemove) {
					lognode.debug("Removing SubValueObject from the list with type: " + subValueObjectToRemove.getType());
					subValueObjects.remove(subValueObjectToRemove);
				}
				
				// Maybe put sorting in sub method in near future
				if (Boolean.TRUE.equals(subTokenObject.getApplySorting(context))) 
				{
					List<IMendixObjectComparable> iMendixObjectComparables = new ArrayList<>();
					
					// Create comparable objects for sorting.
					for (IMendixObject valueObjectSort : subValueObjects) {
						Object mxObjectMemberSortingValue = valueObjectSort.getMember(context, subTokenObject.getSortingAttributeName(context)).getValue(context);
						IMendixObjectComparable iMendixObjectComparable = new IMendixObjectComparable(valueObjectSort, mxObjectMemberSortingValue);
						iMendixObjectComparables.add(iMendixObjectComparable);
					}
					
					// Apply sorting based on String data type attribute.
					if (subTokenObject.getSortingAttributeDataType(context) == DataType.TEXT)
					{
						if (subTokenObject.getSorting() == Sorting.DESCENDING) {
							Collections.sort(iMendixObjectComparables, IMendixObjectStringComparator.DESC);
						} else {
							Collections.sort(iMendixObjectComparables, IMendixObjectStringComparator.ASC);
						}
					}
					
					// Apply sorting based on int data type attribute.
					if (subTokenObject.getSortingAttributeDataType(context) == DataType.WHOLE_NUMBER)
					{
						if (subTokenObject.getSorting() == Sorting.DESCENDING) {
							Collections.sort(iMendixObjectComparables, IMendixObjectIntComparator.DESC);
						} else {
							Collections.sort(iMendixObjectComparables, IMendixObjectIntComparator.ASC);
						}
					}
					
					// Apply sorting based on date data type attribute.
					if (subTokenObject.getSortingAttributeDataType(context) == DataType.DATE)
					{
						if (subTokenObject.getSorting() == Sorting.DESCENDING) {
							Collections.sort(iMendixObjectComparables, IMendixObjectDateComparator.DESC);
						} else {
							Collections.sort(iMendixObjectComparables, IMendixObjectDateComparator.ASC);
						}
					}
					
					// Apply sorting based on decimal data type attribute.
					if (subTokenObject.getSortingAttributeDataType(context) == DataType.DECIMAL_NUMBER)
					{
						if (subTokenObject.getSorting() == Sorting.DESCENDING) {
							Collections.sort(iMendixObjectComparables, IMendixObjectBigDecimalComparator.DESC);
						} else {
							Collections.sort(iMendixObjectComparables, IMendixObjectBigDecimalComparator.ASC);
						}
					}
					
					// Clear list before rebuilding again.
					subValueObjects.clear();
					for (IMendixObjectComparable sortedIMendixObjectComparable : iMendixObjectComparables) {
						subValueObjects.add(sortedIMendixObjectComparable.getIMendixObject());
						
					}
					
					// Cleanup afterwards
					iMendixObjectComparables.clear();
					
				}

				// Set all possible found sub value objects. Can be null, 1 or more.
				nextValueObjects = subValueObjects;

			}

			if (nextValueObjects != null)
			{
				// Process token object again with the next value object.
				text = processTextForTokenObject(subTokenObject, nextValueObjects, text, languageCode);
			}

		}
		
		return text;
		
	}
	
	
	// Process a single token
	private String processToken(IContext context, IMendixObject valueObject, Token token, String languageCode, String text) throws CoreException {
		// Only process token, if the token exists in the text
		if (textContainsSpecificToken(text, token.getCompleteToken(context)))
		{
			Object mxObjectMemberValue = null;
			if (valueObject != null) 
				mxObjectMemberValue = valueObject.getMember(context, token.getAttributeName(getContext())).getValue(context);
			String mxObjectMemberValueAsString = getStringValue(token, mxObjectMemberValue, languageCode);
			return replaceSingleToken(text, token.getCompleteToken(context), mxObjectMemberValueAsString);	
		}
		
		return text;
	}
	
	
	// Get sub token objects
	private List<TokenObject> getTokenObjects(TokenObject parentTokenObject, IContext iContext) {

		// Create list for return.
		List<TokenObject> tokenObjects = new ArrayList<>();

		// Retrieve mapping objects of mapping object.
		List<IMendixObject> iTokenObjects = Core.retrieveByPath(iContext, parentTokenObject.getMendixObject(), TokenObject.MemberNames.TokenObject_TopTokenObject.toString(), true);

		// Iterate through MxObjects and parse to mapping object. Add to list for return.
		for (IMendixObject iTokenObject : iTokenObjects) {

			TokenObject tokenObject = TokenObject.initialize(iContext, iTokenObject);
			tokenObjects.add(tokenObject);

		}		

		// Return filled list.
		return tokenObjects;
	}
		
	
	// Get the possible tokens to parse
	private List<Token> getTokenObjectTokens(TokenObject tokenObject) {
		
		// Create list for return.
		List<Token> tokenList = new ArrayList<>();
		
		List<IMendixObject> iTokenList = Core.retrieveByPath(context, tokenObject.getMendixObject(), Token.MemberNames.Token_TokenObject.toString());
		
		// Iterate through MxObjects and parse to token. Add to list for return.
		for (IMendixObject iToken : iTokenList) {
			
			Token token = Token.initialize(context, iToken);
			tokenList.add(token);
		}
		
		// Return filled list.
		return tokenList;
	}
	
	
	// Replace a single token in the text
	private String replaceSingleToken(String text, String token, String valueText)
	{
		lognode.debug(TokenReplacer.getTitle(context) + "; Language code " + LanguageCode + "; Replacing token " + token + " for " + valueText + ".");
		return text.replace(token, valueText);
	}
	
	
	// Check whether the text still contains tokens
	private boolean textContainsTokens(String text) 
	{
		tokenMatcher = tokenPattern.matcher(text);
		return tokenMatcher.find();
	}
	
	
	// Check if text contains a specific token
	private boolean textContainsSpecificToken(String text, String token) 
	{
		return text.contains(token);
	}
	
	
	// Check whether the text still contains tokens
	private boolean tokenIsInsideListTokens(String text, String token) 
	{
		return (text.indexOf(TOKEN_LIST_START) < text.indexOf(token)) && (text.indexOf(token) < text.indexOf(TOKEN_LIST_END));	
	}
	
	// Check if type is valid to have in the list of sub value objects
	private boolean isValidType(String mxObjectTypeCompleteName, IMendixObject iMxObject) {
		
		boolean isValid = false;
		
		// Get Metaobject to work with and check things.
		IMetaObject iMetaObject = iMxObject.getMetaObject(); 
		
		while (!isValid) {
			if (iMetaObject != null) {
				if (iMetaObject.getName().equals(mxObjectTypeCompleteName)) {
					isValid = true;
				}
				iMetaObject = iMetaObject.getSuperObject();
			} else {
				break;
			}
		}
		
		return isValid;
	}
	
	
	// Get the string value of the Object, to parse with the token.
	private String getStringValue(Token token, Object memberObject, String languageCode) throws CoreException 
	{
		
		if (memberObject == null)
			return "";
		
		String memberObjectValue = "";
		
		// Return value based on specific data type. Possible types are: Long, Boolean, Date, BigDecimal, String, <Enumeration>
		// Considered String.valueof(); Want to be explicit.
		if (memberObject instanceof String && token.getDataType(getContext()) != DataType.ENUMERATION)
		{
			memberObjectValue = memberObject.toString();
		}
		else if (memberObject instanceof Integer)
		{
			memberObjectValue = Integer.toString( (Integer) memberObject);
		}
		else if (memberObject instanceof Long)
		{
			memberObjectValue = Long.toString( (Long) memberObject);
		}
		else if (memberObject instanceof Boolean)
		{
			memberObjectValue = Boolean.toString( (Boolean) memberObject);
		}
		else if (memberObject instanceof Date)
		{
			
			// Determine the date format itself.
	    	String dateFormat = null;
						
			switch (token.getDateFormat(context)) {
			case dd_MM_yyyy: 
				dateFormat = "dd-MM-yyyy"; 
				break;
			case dd_MM_yyyy_HH_mm: 
				dateFormat = "dd-MM-yyyy HH:mm"; 
				break;
			case dd_MMM_yyyy: 
				dateFormat = "dd MMM yyyy"; 
				break;
			case dd_MMM_yyyy_HH_mm: 
				dateFormat = "dd MMM yyyy HH:mm"; 
				break;
			case dd_MMMMM_yyyy: 
				dateFormat = "dd MMMMM yyyy"; 
				break;
			case dd_MMMMM_yyyy_HH_mm: 
				dateFormat = "dd MMMMM yyyy HH:mm"; 
				break;
			case EEE_dd_MMM_yyyy: 
				dateFormat = "EEE dd MMM yyyy"; 
				break;
			case EEE_dd_MMM_yyyy_HH_mm: 
				dateFormat = "EEE dd MMM yyyy HH:mm"; 
				break;
			case EEE_dd_MMMMM_yyyy: 
				dateFormat = "EEE dd MMMMM yyyy"; 
				break;
			case EEE_dd_MMMMM_yyyy_HH_mm: 
				dateFormat = "EEE dd MMMMM yyyy HH:mm"; 
				break;
			case Free_format:
				dateFormat = token.getFreeDateFormat();
				break;

			default: dateFormat = "dd-MM-yyyy";
			}
			
			// Get locale from language code
			Locale locale = getLocale(languageCode);			
			
			// Setup date formatter and format to string.
			SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat, locale);
			
			//Apply time zone if it was provided
			if (TimeZoneID != null && TimeZoneID.length() > 0) {
				simpleDateFormat.setTimeZone(TimeZone.getTimeZone(TimeZoneID));
			}
			
			memberObjectValue = simpleDateFormat.format((Date) memberObject);
			
		}
		else if (memberObject instanceof BigDecimal)
		{
			// Get locale from language code
			Locale locale = getLocale(languageCode);
			
			// Get decimal format and format to string
			DecimalFormat decimalFormat = (DecimalFormat) DecimalFormat.getInstance(locale);
			decimalFormat.setMaximumFractionDigits(token.getNumberOfDecimalsMax(context));
			decimalFormat.setMinimumFractionDigits(token.getNumberOfDecimalsMin(context));
			decimalFormat.setGroupingUsed(token.getApplyGrouping(context));
			
			memberObjectValue = decimalFormat.format(memberObject);
		}
		else if (memberObject instanceof MendixEnum || token.getDataType(getContext()) == DataType.ENUMERATION) // instanceof MendixEnum is lost somehow...
		{
			
			try
			{
				
				IMetaObject metaEntity = Core.getMetaObject(token.getToken_TokenObject(context).getMxObjectTypeCompleteName(context));
			    IMetaPrimitive primitive = metaEntity.getMetaPrimitive(token.getAttributeName(context));
			    IMetaEnumeration metaEnum = primitive.getEnumeration();
			    IMetaEnumValue enumValue = metaEnum.getEnumValues().get(memberObject);
				
				if (token.getParserMethod(context) == ParserMethod._DEFAULT || token.getParserMethod(context) == null)
				{
					memberObjectValue = Core.getInternationalizedString(languageCode, enumValue.getI18NCaptionKey());
				}
				else 
				{
					memberObjectValue = memberObject.toString();
				}
			} 
			catch (Exception e)
			{
				lognode.warn(TokenReplacer.getTitle(context) + "; Language code " + languageCode + "; Token " + token.getCompleteToken(context) + ": Failed to get enumeration value."); 
				memberObjectValue = memberObject.toString();
			}

		}
		
		// Check if parser is applied. If so > find the value to parse to.
		if (token.getParserMethod(context) == ParserMethod._DEFAULT || token.getParserMethod(context) == null)
		{
			if (Boolean.TRUE.equals(token.getEscapeParsedValue(context))) 
			{
				memberObjectValue = StringEscapeUtils.escapeHtml4(memberObjectValue);
			}
			return memberObjectValue;
			
		}
		else 
		{
			
			// Future use XPath escaped?
			String contentParserXPathQuery = "//" 
					+ ContentParser.getType()
					+ "[" + ContentParser.MemberNames.ContentParser_Token + "='" + token.getMendixObject().getId().toLong() + "']"
					+ "[" + ContentParser.MemberNames.LanguageCode + "='" + languageCode + "']"
					+ "[" + ContentParser.MemberNames.Value + "='" + memberObjectValue + "']";
			
			// Execute the query
			List<IMendixObject> iContentParsers = Core.retrieveXPathQuery(context, contentParserXPathQuery, 1);
			
			if (iContentParsers.isEmpty())
				return "";
						
			// Initialize result to ContentParser
			ContentParser contentParser = ContentParser.load(context, iContentParsers.get(0).getId());	
			memberObjectValue = contentParser.getParseToValue(context);
			
			if (Boolean.TRUE.equals(token.getEscapeParsedValue(context))) 
			{
				memberObjectValue = StringEscapeUtils.escapeHtml4(memberObjectValue);
			}
			
			return memberObjectValue;
			
		}

	}
	
	// Get the current Locale based on a language code
	private Locale getLocale(String languageCode)
	{
		String[] parts = languageCode.split("_");
		
		switch (parts.length) {
		case 3: 
			return new Locale(parts[0], parts[1], parts[2]);
		case 2:
			return new Locale(parts[0], parts[1]);
		case 1:
			return new Locale(parts[0]);
		
		default: return new Locale(Locale.ENGLISH.toString());
		}
		
	}
	
	
	// END EXTRA CODE
}
